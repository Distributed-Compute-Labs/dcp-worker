#! /usr/bin/env node
/**
 * @file        dcp-screensaver-evaluator               
 *              Daemon to monitor the state of the system screensaver, and
 *              enable/disable the evaluator as appropriate.
 *
 *              The actual mechanics of communicating with the evaluator is
 *              similar in principle to how inetd works, and the code is, in
 *              fact, based on the dcp inet-daemon.
 *
 * @author      Wes Garland, wes@distributive.network
 * @date        June 2018, Sep 2022
 */
'use strict';

const net   = require('net')
const dns   = require('dns');
const debug = require('debug');

var ssActive = false; /* true => allow evaluator connections */
var children;
var seq = 0;

const daemonConfig = {
  net:  new URL('tcpip://localhost:9000/'),
  proc: require.resolve('./dcp-evaluator-start'),
  argv: ['-se', '/opt/dcp/bin/dcp-evaluator', '-l', '/opt/dcp/libexec/evaluator/']
};

/**
 * Establish listening socket evaluator proxy 
 */
async function listenForConnections(config)
{
  var server = net.createServer((socket) => handleConnection(socket, config));
  var hostaddr;
  
  if (config.net.hostname === 'localhost')
    hostaddr = '::';
  else
    hostaddr = await dns.promises.lookup(config.net.hostname, { family: 4 });

  server.on('error', (error) => {
    delete error.stack;
    console.error(error);
    process.exit(2);
  });

  require('dcp-client');
  children = new (require('dcp/utils').Inventory)();

  server.listen({ host: hostaddr, port: config.net.port }, function daemonReady() {
    console.log('Listening for connections on', server._connectionKey);
  });
}

/**
 * Handle and incoming connection. If the screensaver is not active, the conneciton
 * is immediately rejected. Otherwise, we spin up an evaluator process and proxy its
 * stdio to the socket.
 */
function handleConnection (socket, config)
{
  var child;
   
  if (ssActive)
    debug('dcp-screensaver')('New connection; spawning ', config.proc, config.argv);
  else
  {
    debug('dcp-screensaver')('New connection; closing');
    socket.end();
    socket.destroy();
    return;
  }
  
  child = require('child_process').spawn(config.proc, config.argv);
  child.stderr.setEncoding('ascii')
  child.socket = socket;
  children.add(child);
  child.id = ++seq;
  debug('dcp-screensaver')(`Spawned worker process ${child.pid} for child ${child.id}`);

  socket.on('end', function socketEnd() {
    debug('dcp-screensaver')('Socket end; killing child', child.id);
    child.kill();
  });

  socket.on('error', function socketError(error) {
    debug('dcp-screensaver')(`Socket error ${error.code}; killing child`, child.id);
    debug('dcp-screensaver')(error);
    socket.destroy();
    child.kill();
  });

  child.on('error', function childError(error) {
    console.error('Error from worker ' + child.id + ':', error);
    socket.destroy();
    child.kill();
    children.delete(child);
  });

  child.on('exit', function(code) {
    debugger;
    debug('dcp-screensaver')(`child ${child.id} exited; closing socket`, code || '');
    socket.end();
    socket.destroy();
    children.delete(child);
  });

  child.stdout.on('data', function (data) {
    debug('dcp-screensaver:network')('<', child.id, bufToDisplayStr(data), 93);
    socket.write(data)
  });

  child.stderr.on('data', function (data) {
    console.log('child ' + child.id + ' stderr: ', data);
  });

  socket.on('data', function (data) {
    debug('dcp-screensaver:network')('>', child.id, bufToDisplayStr(data, 93));

    try
    {
      child.stdin.write(data)
    }
    catch (error)
    {
      console.warn('could not write to child process (', child.pid, ', index', child.id, ') stdin')
      throw error;
    }
  })
}

/** 
 * Format detailed debug output of raw socket traffic
 */
function bufToDisplayStr (buf, limit)
{
  const str = buf.toString('utf-8').replace(/\n/, '\u2424').toString('utf-8');

  if (typeof limit === 'number' && str.length > limit)
    return str.substr(0, limit) + '\u2026';
  else
    return str;
}

/**
 * Kill all evaluators as quickly as possible.
 */
async function killChildren()
{
  for (let child of children)
  {
    debug('dcp-screensaver')(`killing child ${child.pid}`);
    child.kill('SIGKILL');
  }
}

/** 
 * Monitor dbus messages for screensaver start / stop events.
 */
async function dbusMonitor()
{
  const dbus = require('dbus-next');
  const bus = dbus.sessionBus();
  const screensaverList = [
    'org.gnome.ScreenSaver',
    'org.cinnamon.ScreenSaver',
    'org.kde.screensaver',
    'org.freedesktop.ScreenSaver'
  ];
  var iface;

  for (let ss of screensaverList)
  {
    try
    {
      let obj = await bus.getProxyObject(ss, '/' + ss.replace(/\./g, '/'));
      if (obj)
      {
        iface = obj.interfaces[ss];
        break;
      }
    }
    catch (error)
    {
      debug('dcp-screensaver:dbus')('Could not acquire screensaver', ss + '; trying next', error);
    }
  }

  if (!iface)
  {
    console.error('Could not open dbus session to any screensaver, tried', screensaverListe);
    process.exit(3);
  }

  ssActive = await iface.GetActive();
  debug('dcp-screensaver')('Screen saver active:', ssActive);

  iface.on('ActiveChanged', function screenSaverChangeHandler(active) {
    ssActive = active;
    if (!active)
      killChildren();
    debug('dcp-screensaver')(`screen saver ${active ? 'started' : 'finished'} at`, new Date());
  });

  console.log('Monitoring screensaver', iface.$name);
}

/* Main program entry point */
function main()
{
  process.on('uncaughtException', function (e) {
    console.error('\n---', (new Date()).toLocaleString(), '-------------------------------------------------')
    console.error('uncaught exception:', e.stack)
    console.error('\n')
  });

  process.on('unhandledRejection', function (e) {
    console.error('\n---', (new Date()).toLocaleString(), '-------------------------------------------------')
    console.error('unhandled rejection:', e.stack)
    console.error('\n')
  })

  dbusMonitor();
  listenForConnections(daemonConfig);
}

main();
