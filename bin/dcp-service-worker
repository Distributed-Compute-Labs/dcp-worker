#! /usr/bin/env node
/**
 *  @file       dcp-service-worker
 *              Standalone NodeJS DCP Worker
 *
 *  @author     Ryan Rossiter, ryan@kingsds.network
 *              Eddie Roosenmaallen, eddie@kingsds.network
 *  @date       April 2020
 */
'use strict';

const process = require('process');
const os = require('os');

const DEFAULT_CORES = os.cpus().length - 1;

console.log(` * Starting DCP Service Worker`);

require('dcp-client').init(require(process.env.DCP_CONFIG || '../etc/dcp-config.js'))
.then(main)
.then((exitcode = 0) => process.exit(exitcode))
.catch(e => {
  console.error("Script failed:");
  console.error(e);
  process.exit(1);
});

async function main() {
  const dcpConfig = require('dcp/dcp-config');
  var sawOptions;

  require('../lib/check-scheduler-version').check();

  const cliArgs = require('dcp/cli')
    .base('DCP Service Worker')
    .options({
      cores: {
        alias: ['c', 'defaultSandboxes'],
        describe: 'Number of cores to work with',
        type: 'number',
        default: DEFAULT_CORES,
      },
      verbose: {
        alias: 'v',
        describe: 'Enable verbose output',
        type: 'count',
        group: 'Output options',
      },
      output: {
        alias: 'o',
        describe: 'Specify the output mode',
        type: 'string',
        choices: ['console', 'syslog', 'file', /*NYI: 'multi-file',*/ 'event-log'],
        default: 'console',
        group: 'Output options',
      },
      hostname: {
        alias: 'H',
        describe: 'Evaluator hostname',
        type: 'string',
        default: dcpConfig.evaluator.location.hostname,
      },
      port: {
        alias: 'p',
        describe: 'Evaluator port',
        type: 'number',
        default: Number(dcpConfig.evaluator.location.port),
      },
      identityKey: {
        describe: 'Identity key, in hex format',
        type: 'string',
        group: 'Identity options',
      },
      identityKeystore: {
        describe: 'Identity keystore, in json format',
        type: 'string',
        group: 'Identity options',
      },
      output: {
        alias: 'o',
        describe: 'Specify the output mode',
        type: 'string',
        choices: ['console', 'syslog', 'file', /*NYI: 'multi-file',*/ 'event-log'],
        group: 'Output options',
      },
      verbose: {
        alias: 'v',
        describe: 'Enable verbose output',
        type: 'count',
        group: 'Output options',
      },
      reportInterval: {
        describe: 'If set, output a status summary every [interval] seconds',
        type: 'number',
        group: 'Output options',
      },
      eventDebug: {
        hide: true,
        describe: 'If set, dump all sandbox and worker events',
      },
      logfile: {
        describe: 'Path to log file (if --output=file)',
        type: 'string',
        group: 'Log File output options',
      },
       syslogAddress: {
        describe: 'Address of rsyslog server (if --output=syslog)',
        type: 'string',
        group: 'Syslog output options',
      },
      syslogTransport: {
        describe: 'Transport to connect to rsyslog daemon (if --output=syslog)',
        type: 'string',
        choices: ['udp','tcp'],
        group: 'Syslog output options',
      },
      syslogPort: {
        describe: 'UDP/TCP port of rsyslog server',
        type: 'number',
        group: 'Syslog output options',
      },

      replPort: {
        describe: 'If set, open a REPL on specified TCP port',
        type: 'number',
        default: undefined,
      },
    })
  .strict()
  .wrap(process.stdout.columns || 80)
  .argv;
 
  const addressFromCLI = cliArgs._.find(opt => {
    return (typeof opt === 'string'
      && opt.match(/^(0x)?[0-9a-fA-F]{40}$/));
  });
  
  if (!cliArgs.paymentAddress && !!addressFromCLI) {
    cliArgs.paymentAddress = addressFromCLI;
  }
  
  const wallet = require('dcp/wallet');
  const DCPWorker = require('dcp/worker');
  
  /* Overlay serviceWorker delta on top of standaloneWorker; code uses standaloneWorker internally */
  require('dcp/utils').leafMerge(dcpConfig.standaloneWorker, dcpConfig.serviceWorker);
  
  let identityKeystore = false;

  // Different ways to get the identity
  if (cliArgs.identityKey) {
    identityKeystore = await new wallet.Keystore(cliArgs.identityKey, '');
  }
  else if (cliArgs.identityKeystore) {
    identityKeystore = await new wallet.Keystore(JSON.parse(cliArgs.identityKeystore), '');
    // Set the provided identity as the wallet's default
    await wallet.addId(identityKeystore);
  }
  else {
    identityKeystore = await wallet.getId();
  }

  let paymentAddress;
  if (cliArgs.paymentAddress) {
    paymentAddress = new wallet.Address(cliArgs.paymentAddress);
  } else {
    paymentAddress = (await wallet.get()).address;
  }

  const exitGuard = {};
  exitGuard.promise = new Promise(resolve => {
    exitGuard.exit = resolve;
  });

  let workerHasStarted = false;
  sawOptions = {
    hostname: cliArgs.hostname,
    port:     cliArgs.port
  };
  sawOptions.onsocketerror = function saw$onsocketerror(error, worker) {
    // If we've been connected to the evalserver, then we should
    // return any work we have, and exit
    if (workerHasStarted) {
      console.error('167: evaluator server has gone away; terminating worker.');
      exitGuard.exit(12); // error code 0x0C indicates "worker should restart"
    }
  };

  const SAWorker = require('../lib/standaloneWorker').workerFactory(sawOptions);
  const worker = new DCPWorker({
    paymentAddress,
    maxWorkingSandboxes: cliArgs.cores,
    sandboxOptions: {
      SandboxConstructor: SAWorker
    },
  });
  
  // Set the flag to indicate we've seen the evalserver
  worker.once('fetch', () => {
    workerHasStarted = true;
  })
  
  if (process.env.TEST_HARNESS) {
    const { bindToTestHarness } = require('.../lib/bindToTestHarness');
    bindToTestHarness(worker);
  }

  // replace console.log with the appropriate handler
  const consolePatch = require('../lib/console-patch');
  
  switch(cliArgs.output) {
    case 'file':
      consolePatch.patch(new consolePatch.Consoles.LogfileConsole(cliArgs.logfile || './worker.log'));
      break;
    case 'syslog':
      // @todo: sort out any syslog options
      consolePatch.patch(new consolePatch.Consoles.SyslogConsole(
        cliArgs.syslogAddress || '127.0.0.1',
        {
          transport: cliArgs.syslogTransport === 'udp' ? require('syslog-client').Transport.Udp : require('syslog-client').Transport.Tcp,
          port: cliArgs.syslogPort || undefined,
        }
      ));
      break;
    case 'event-log':
      consolePatch.patch(new consolePatch.Consoles.EventLogConsole());
      break;
    case 'console':
    default:
      // do nothing, use the default console
  }

  console.log(` . Configured for scheduler ${dcpConfig.scheduler.location.href}`);
  console.log(` . Earned funds will be deposited in account ${paymentAddress} in bank ${dcpConfig.bank.location.href}`);
  console.log(` . Identity is ${identityKeystore.address} ${identityKeystore.label && `(${identityKeystore.label})`}`);
  if (cliArgs.verbose)
    console.log(` . Verbosity level: ${cliArgs.verbose}`);
  if (cliArgs.eventDebug)
    console.log(` . Event debug on`);
  
  console.log(' . output mode: ' + cliArgs.output);
  
  if (cliArgs.eventDebug) {
    worker.debug = true;
    worker.supervisor.debug = true;
  }
  
  if (cliArgs.verbose >= 2) {
    worker.on('payment', ev => {
      console.log(' * worker::payment', ev.payment, ev.accepted ? 'accepted' : ev.reason);
    });
    worker.on('fetchstart', () => console.log(' * worker::fetchstart'));
    // worker.on('fetch', () => console.log(' * worker::fetch'));
    worker.on('fetchend', () => console.log(' * worker::fetchend'));
  }
  
  if (cliArgs.verbose >= 1)
    worker.on('fetchError', error => console.error(' * worker::fetchError', error));
  
  // Attach sandbox-specific listeners
  worker.on('sandbox', sandbox => {
    const sbId = sandbox.id;
    const sbKey = `sandbox ${sbId}`;
    
    if (cliArgs.verbose >= 1)
      console.log(' * worker::sandbox', sbId);
    
    if (cliArgs.verbose >= 2) {
      sandbox.on('slicestart', ev => {
        const { job, sandbox: { jobAddress, requiresGPU } } = ev;
        console.log(
          ` * ${sbKey}::slicestart`,
          job.publicName,
          jobAddress,
          requiresGPU ? 'GPU' : 'CPU-only'
        );
      });
      
      sandbox.on('complete', ev => {
        const { result } = ev;
        console.log(
          ` * ${sbKey}::complete`,
          (result instanceof Error) ? result.message : 'ok'
        );
      });
    }
    
    sandbox.on('error', error => {
      const { name, code, message, stack } = error;
      console.error(
        ` * ${sbKey}::error`,
        {
          name,
          code,
          error,
          message,
        },
      );
    });
    
    sandbox.on('workerStop', ev => {
      console.error(
        ` * ${sbKey}::workerStop`,
      );
    });
  });
  
  if (cliArgs.replPort) {
    const replConfig = {
      repl: {
        port: cliArgs.replPort,
      },
    }
    require('./lib/service-repl').start(replConfig, function rsEval() { return eval(arguments[0]) });
  }

  worker.start();
  
  process.on('SIGUSR1', () => printReport());
  
  if (cliArgs.reportInterval) {
    const noise = setInterval(()=>printReport(),  cliArgs.reportInterval * 1000);
    noise.unref();
  }
  
  process.on('SIGQUIT', () => {
    console.log('\n*** caught SIGQUIT; exiting...\n');
    exitGuard.exit('SIGQUIT');
  });

  let exitcode = 0;
  await exitGuard.promise.then(result => exitcode = result);
  
  await worker.stop(true)
  .catch(error => {
    // Trap crash-causing schedmsg error
    if (error.message.includes('Can\'t stop SchedMsg'))
      return;
    
    throw error;
  });
  
  return exitcode;
  
  function printReport() {
    const sup = worker.supervisor;

    console.log('='.repeat(78));

    const sbStates = {
      WORKING: 0,
      ASSIGNED: 0,
      READY: 0,
      TERMINATED: 0,
    };
    const stateNames = {
      WORKING: 'Working',
      ASSIGNED: 'Assigned',
      READY: 'Ready',
      TERMINATED: 'Terminated',
    };
    sup.sandboxes.forEach(sb => {
      const { state } = sb;
      if (!sbStates[state])
        sbStates[state] = 0;
      sbStates[state]++;
    });

    console.log(Date());
    console.log('Sandboxes:');
    // console.log(`  working:     ${sup.workingSandboxes.length} / ${options.cores} (${sup.GPUsAssigned} assigned GPUs)`);
    // console.log(`  assigned:    ${sup.assignedSandboxes.length}`);
    // console.log(`  readied:     ${sup.readiedSandboxes.length}`);
    // console.log(`  terminated:  ${sup.terminatedSandboxes.length}`);
    Object.keys(sbStates).forEach(state => {
      const stateName = stateNames[state] || state;
      console.log(`  ${(stateName + ':').padEnd(12)} ${sbStates[state]}`);
    })
    console.log(`  * ALL:       ${sup.sandboxes.length}`);
    
    console.log('Progress:');
    sup.workingSandboxes.forEach(sb => {
      const jobName = sb.job && sb.job.public && sb.job.public.name || `idek (${sb.jobAddress})`;
      let el = Date.now() - sb.sliceStartTime;
      const t = el < 1000000
        ? toInterval(el)
        : 'new';
      
      el = sb.progressReports && sb.progressReports.last
        ? Date.now() - (sb.sliceStartTime + sb.progressReports.last.timestamp)
        : 0;
      const pct = (typeof sb.progress) === 'number'
        ? `${Number(sb.progress).toFixed(0).padStart(2)}%`
        : 'ind';
      const stale = (el < 2000) ? '' : `(stale: ${toInterval(el)})`;
      
      console.log(` ${String(sb.id).padStart(4)}: ${sb.jobAddress} ${jobName.padEnd(34)} `+ `${t} ${pct} ${stale}`.padStart(13));
    });
    
    console.log('Slices:');
    console.log(`  working:     ${sup.workingSlices.length}`);
    console.log(`  queued:      ${sup.queuedSlices.length}`);

    console.log('='.repeat(78));
  }
  
  function toInterval(el) {
    const m = Math.floor(el / 1000 / 60).toString(10);
    const s = Math.floor((el / 1000) % 60).toString(10).padStart(2, '0');
    return `${m}:${s}`;
  }
}
