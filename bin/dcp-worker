#!/usr/bin/env node
/**
 *  @file       dcp-worker.js
 *              Standalone NodeJS DCP Worker
 *
 *  @author     Ryan Rossiter, ryan@kingsds.network
 *  @date       April 2020
 */
'use strict';

const process = require('process');
const os = require('os');
const fs = require('fs');

// Set to true to try to understand unhandled rejection.
const ANALYZE_UNHANDELD_REJECTION = false;

// Set default location for pid file
let DEFAULT_PID_LOC;
if (fs.existsSync('/var/dcp/run'))
  DEFAULT_PID_LOC = '/var/dcp/run/';
else if (fs.existsSync('/var/run'))
  DEFAULT_PID_LOC = '/var/run/';
else
  DEFAULT_PID_LOC = os.tmpdir();

const TOTAL_CPU_VCORES = os.cpus().length;
const DEFAULT_CORES = TOTAL_CPU_VCORES - 1;
var worker, dcpConfig;

const EXIT_CLEAN           = 0;   // normal exit, no error
const EXIT_SIGQUIT         = 2;   // received SIGQUIT
const EXIT_ERROR_STOPPING  = 3;   // failed to stop worker, no other error
const EXIT_TIMED_OUT       = 4;   // failed to exit after requesting graceful exit
const EXIT_UNHANDLED       = 5;   // unhandled rejection


process.on('unhandledRejection', (error) => {
  console.error('Unhandled rejection:', error);
});

async function main () {
  if (!ANALYZE_UNHANDELD_REJECTION)
    process.on('unhandledRejection', unhandledRejectionHandler);

  await require('dcp-client').init({
    configName: '../etc/dcp-config',
  });

  dcpConfig = require('dcp/dcp-config');

  const cliArgs = require('dcp/cli')
  .base('Standalone NodeJS DCP Worker')
    .options({
      paymentAddress: {
        describe: 'The address to deposit funds into, will use the default bank keystore if not provided.',
        type: 'string',
      },
      cores: {
        alias: 'c',
        describe: 'Number of cores to work with',
        type: 'number',
        default: DEFAULT_CORES,
      },
      verbose: {
        alias: 'v',
        describe: 'Enable verbose output',
        type: 'count',
        default: false,
        group: 'Output options',
      },
      outputMode: {
        alias: ['o', 'output'],
        describe: 'Set the output mode',
        type: 'string',
        default: 'detect',
        choices: ['detect', 'console', 'dashboard', 'event-log', 'syslog', 'logfile'],
        group: 'Output options',
      },
      hostname: {
        alias: 'H',
        describe: 'Evaluator hostname',
        type: 'string',
        default: dcpConfig.evaluator.location.hostname,
      },
      port: {
        alias: 'p',
        describe: 'Evaluator port',
        type: 'number',
        default: Number(dcpConfig.evaluator.location.port),
      },
      priorityOnly: {
        alias: 'P',
        describe: 'Set the priority mode [deprecated]',
        type: 'boolean',
        default: false
      },
      'job-id': {
        alias: 'j',
        describe: 'Restrict worker to a specific job (use N times for N jobs)',
        type: 'array',
      },

      join: {
        alias: 'g',
        describe: 'Join compute group; the format is "joinKey,joinSecret" or "joinKey,eh1-joinHash"',
        type: 'array'
      },
      joinKeystore: {
        hidden: true,
        /* future */
      },

      leavePublicGroup: {
        type: 'boolean',
        describe: 'Do not fetch slices from public compute group',
        default: false,
      },
      publicGroupFallback: {
        describe: 'If set, worker will prefer private groups but fall back on the public group if no preferred work is available',
        type: 'boolean',
        default: false,
      },

      identityKey: {
        describe: 'Identity key, in hex format',
        type: 'string',
        group: 'Identity options',
      },
      identityKeystore: {
        describe: 'Identity keystore, in json format',
        type: 'string',
        group: 'Identity options',
      },

      reportInterval: {
        describe: 'If set, output a status summary every [interval] seconds in console output mode',
        type: 'number',
        group: 'Output options',
      },
      eventDebug: {
        hide: true,
        describe: 'If set, dump all sandbox and worker events',
      },

      logfile: {
        describe: 'Path to log file (if --output=file)',
        type: 'string',
        group: 'Log File output options',
      },
      syslogAddress: {
        describe: 'Address of rsyslog server (if --output=syslog)',
        type: 'string',
        group: 'Syslog output options',
      },
      syslogTransport: {
        describe: 'Transport to connect to rsyslog daemon (if --output=syslog)',
        type: 'string',
        choices: ['udp','tcp'],
        group: 'Syslog output options',
      },
      syslogPort: {
        describe: 'UDP/TCP port of rsyslog server',
        type: 'number',
        group: 'Syslog output options',
      },

      allowedOrigins: {
        alias: 'a',
        describe: 'modify the \'any\' allow origins of dcpConfig',
        type: 'array'
      },

      replPort: {
        describe: 'If set, open a REPL on specified TCP port',
        type: 'number',
        default: undefined,
      },
      watchdogInterval: {
        alias: 'W',
        describe: 'Number of milliseconds between watchdog cycles',
        type: 'number',
        hidden: true,
      },
      dumpConfig: {
        describe: 'If set, dump the configuration and exit',
        type: 'boolean',
        hidden: true,
      },
      pidFileLoc: {
        alias: 'f',
        describe: 'If set, location to generate the worker pid file',
        normalize: true
      },
    })
  .strict()
  .wrap(process.stdout.columns || 80)
  .argv;

  if (cliArgs.dumpConfig)
  {
    console.debug(JSON.stringify(require('dcp/dcp-config'), null, 2));
    process.exit(1);
  }

  return startWorking(cliArgs);
}

// Preserve console.error, the dashboard replaces it with a custom logger
const logError = console.error;
main()
.then(exitcode => process.exit(exitcode || 0))
.catch(e => {
  logError("Script failed:");
  logError(e);
  process.exit(1);
});

// Imperfect, but handles CG { joinKey, joinHash }.
function isHash(b) {
  return b && b.length === 68 && b.startsWith('eh1-');
}

async function startWorking(cliArgs) {
  //console.log('cliArgs', cliArgs);
  const wallet = require('dcp/wallet');
  const DCPWorker = require('dcp/worker').Worker;
  const { startWorkerLogger } = require('../lib/startWorkerLogger');
  const sawOptions = {
    hostname: cliArgs.hostname,
    port:     cliArgs.port
  };

  let paymentAddress;
  if (cliArgs.paymentAddress)
    paymentAddress = new wallet.Address(cliArgs.paymentAddress);
  else
    paymentAddress = (await wallet.get()).address;

  if (cliArgs.pidFileLoc)
    memoizePid(cliArgs.pidFileLoc)

  // Different ways to get the identity: 
  let identityKeystore = false;

  if (cliArgs.identityKey)
    identityKeystore = await new wallet.IdKeystore(cliArgs.identityKey, '');
  else if (cliArgs.identityKeystore)
    identityKeystore = await new wallet.IdKeystore(JSON.parse(cliArgs.identityKeystore), '');
  else
    identityKeystore = await wallet.getId();

  // Set the provided identity as the wallet's default
  await wallet.addId(identityKeystore);


  if (typeof dcpConfig.worker.unhandledRejectionCleanupTimeout !== 'undefined')
    unhandledRejectionHandler.timeout = dcpConfig.worker.unhandledRejectionCleanupTimeout;

  // Leave the public compute group, if desired
  if (cliArgs.leavePublicGroup || cliArgs.publicGroupFallback)
    dcpConfig.worker.leavePublicGroup = true;


  // The exitGuard will hold an "exit" method, and a Promise to await for
  // the exit code passed to exitGuard.exit()
  let exitcode = EXIT_CLEAN;
  const exitGuard = {
    promise: Promise.resolve(0),                     // will be overwritten when worker starts
    exit(code) { process.exit(code||exitcode||0) },  // will be overwritten when worker starts
  };
  process.on('SIGQUIT', () => {
    exitcode = EXIT_SIGQUIT;
    cliArgs.verbose >= 1 && console.info(`240: Caught SIGQUIT; exiting worker with exitcode ${exitcode}`);
    exitGuard.exit(exitcode);
  });


  /** @type {string[]} */
  const dcpWorkerOptions = dcpConfig.worker;

  Object.assign(dcpWorkerOptions, {
    paymentAddress,
    maxWorkingSandboxes: cliArgs.cores,
    cores:               { cpu: TOTAL_CPU_VCORES, gpu: undefined }, /** XXXpfr @todo: Figure out how many gpus. */
    targetLoad:          { cpu: 1.0, gpu: 1.0 }, /** Use 100%: XXXpfr @todo Allow command-line override. */
    sandboxOptions: {
      SandboxConstructor: require('dcp-client/lib/standaloneWorker').workerFactory(sawOptions)
    },
    computeGroups: [], /* public group is implied */
    leavePublicGroup: cliArgs.leavePublicGroup || dcpConfig.worker.leavePublicGroup,
  });

  /* cliArgs.join is the list of compute groups to join */
  if (cliArgs.join && cliArgs.join.length)
  {
    dcpWorkerOptions.computeGroups = cliArgs.join
      .map((el) => {
        /* Map cliArgs.join to give us [{ joinKey, joinSecret/joinHash }...] */
        const [a, b] = el.split(',');
        return isHash(b) ? { joinKey: a, joinHash: b } : { joinKey: a, joinSecret: b };
      })
      .filter((el) => el.joinKey); /* Filter out entries with no joinKey */
    //console.log(dcpWorkerOptions.computeGroups);
  }
  
  if (cliArgs.jobId)
  {
    dcpWorkerOptions.jobAddresses = cliArgs.jobId;
    dcpWorkerOptions.priorityOnly = true;
  }
  if (cliArgs.allowedOrigins)
    dcpConfig.worker.allowOrigins.any.concat( cliArgs.allowedOrigins );
  if (cliArgs.watchdogInterval)
    dcpWorkerOptions.watchdogInterval = cliArgs.watchdogInterval;

    worker = new DCPWorker(identityKeystore, dcpWorkerOptions);

  /**
   * NOTE: In Supervisor2 this function is a NOOP.
   * When (and if) we stop using Supevisor1, delete this reference to setDefaultIdentityKeystore
   * and delete the corresponding fucntion from Supervisor2.
   *
   * startWorkerLogger needs to be called before the worker is started so that
   * it can attach event listeners before the events fire, else UI events for
   * things such as progress will never get attached.
   *
   * setDefaultIdentityKeystore needs to be called before the logger because it
   * tries access the identity of the worker before it has started, i.e. where
   * it sets its identity, throwing an assertion error.
   *
   * FIXME(bryan-hoang): This is a fragile solution that is too coupled with the
   * implementation of the worker that should be addressed in Supervisor 2
   */
  await worker.supervisor.setDefaultIdentityKeystore();


  if (cliArgs.eventDebug)
  {
    worker.debug = true;
    worker.supervisor.debug = true;
  }


  // if the worker stops internally (eg. schedmsg stop), then exit without
  // changing the saved exitcode
  worker.on('stop', () => {
    exitGuard.exit();
  });


  startWorkerLogger(worker, {
    exitGuard,
    verbose: cliArgs.verbose,
    outputMode: cliArgs.outputMode,

    logfile: cliArgs.logfile,

    syslogAddress: cliArgs.syslogAddress,
    syslogTransport: cliArgs.syslogTransport,
    syslogPort: cliArgs.syslogPort,
  });

  try
  {
    require('../lib/remote-console').init(cliArgs.replPort, {
      help: {
        report: 'Print a worker status & slice report',
        kill: 'Kill the worker',
      },
      commands: {
        report: printReport,
        kill: exitcode => exitGuard.exit(exitcode),
      },
    });
    require('../lib/remote-console').setMainEval(function mainEval() { return eval(arguments[0]) });
  }
  catch (error)
  {
    console.warn('350: Failed to initialize remote console:', error.message);
  }

  let introBanner = '';
  introBanner += ` * Starting DCP Worker` + '\n';
  introBanner += ` . Configured for scheduler ${dcpConfig.scheduler.location}` + '\n';
  introBanner += ` . Bank is ${dcpConfig.bank.location}` + '\n';
  introBanner += ` . Earned funds will be deposited in account ${paymentAddress}` + '\n';
  introBanner += ` . Identity is ${identityKeystore.address}` + '\n';

  function qty(amount, singular, plural) /* XXX i18n */
  {
    if (Array.isArray(amount))
      amount = amount.length;
    if (!plural)
      plural = singular + 's';
    if (!amount)
      return plural;
    if (amount == 1)
      return singular;
    return plural;
  }

  if (dcpWorkerOptions.jobAddresses)
    introBanner += ` * Processing only ${qty(dcpWorkerOptions.jobAddresses, 'job')} ` + dcpWorkerOptions.jobAddresses.join(', ') + '\n';
  if (dcpWorkerOptions.computeGroups.length)
    introBanner += ` * Joining compute ${qty(dcpWorkerOptions.computeGroups, 'group')} ` + dcpWorkerOptions.computeGroups.map(el => el.joinKey).join(', ') + '\n';
  if (dcpWorkerOptions.publicGroupFallback)
    introBanner += ' * Falling back on public group when preferred groups have no work' + '\n';
  else if (dcpWorkerOptions.leavePublicGroup)
    introBanner += ' * Leaving the public compute group' + '\n';
  if (cliArgs.verbose)
    introBanner += ` + Verbosity level: ${cliArgs.verbose}` + '\n';
  if (cliArgs.eventDebug)
    introBanner += ' + Event debug on' + '\n';
  introBanner += ' . output mode: ' + cliArgs.outputMode + '\n';
  
  introBanner += ' . ready' + '\n';

  console.log(introBanner);

  require('../lib/check-scheduler-version').check();


  /** print the slice report via console.log */
  function printReport()
  {
    console.log(sliceReport());
  }

  /** retrieve a slice report screen */
  function sliceReport()
  {
    const sup = worker.supervisor;
    let report = '';

    report += ('='.repeat(78)) + '\n';

    const sbStates = {
      WORKING: 0,
      ASSIGNED: 0,
      READY: 0,
      TERMINATED: 0,
    };
    const stateNames = {
      WORKING: 'Working',
      ASSIGNED: 'Assigned',
      READY: 'Ready',
      TERMINATED: 'Terminated',
    };
    sup.sandboxes.forEach(sb => {
      const { state } = sb;
      if (!sbStates[state])
        sbStates[state] = 0;
      sbStates[state]++;
    });

    report += (Date()) + '\n';
    report += ('Sandboxes:') + '\n';
    Object.keys(sbStates).forEach(state => {
      const stateName = stateNames[state] || state;
      report += (`  ${(stateName + ':').padEnd(12)} ${sbStates[state]}`) + '\n';
    })
    report += (`  * ALL:       ${sup.sandboxes.length}`) + '\n';

    report += ('Progress:') + '\n';
    sup.workingSandboxes.forEach(sb => {
      const jobName = sb.job && sb.job.public && sb.job.public.name || `idek (${sb.jobAddress})`;
      let el = Date.now() - sb.sliceStartTime;
      const t = el < 1000000
        ? toInterval(el)
        : 'new';

      el = sb.progressReports && sb.progressReports.last
        ? Date.now() - (sb.sliceStartTime + sb.progressReports.last.timestamp)
        : 0;
      const pct = (typeof sb.progress) === 'number'
        ? `${Number(sb.progress).toFixed(0).padStart(2)}%`
        : 'ind';
      const stale = (el < 2000) ? '' : `(stale: ${toInterval(el)})`;

      report += (` ${String(sb.id).padStart(4)}: ${sb.jobAddress} ${jobName.padEnd(34)} `+ `${t} ${pct} ${stale}`.padStart(13)) + '\n';
    });

    report += ('Slices:') + '\n';
    report += (`  working:     ${sup.allocatedSlices.length}`) + '\n';
    report += (`  queued:      ${sup.queuedSlices.length}`) + '\n';

    report += ('='.repeat(78)) + '\n';

    return report;
  }

  /**
   *  Convert a timespan in ms to a human-readable interval in minutes and seconds
   *
   *  @param  {number} el Milliseconds to convert
   *  @return {string}    Timespan formatted as `m:ss`
   */
  function toInterval(el)
  {
    const m = Math.floor((el / 1000) / 60).toString(10);
    const s = Math.floor((el / 1000) % 60).toString(10).padStart(2, '0');
    return `${m}:${s}`;
  }

  if (parseFloat(cliArgs.reportInterval))
  {
    if (cliArgs.outputMode !== 'dashboard')
      setInterval(printReport, parseFloat(cliArgs.reportInterval) * 1000);
    else
      console.log('Ignoring --reportInterval in dashboard output mode');
  }


  // Set the exit guard - this method can be called by signal and exception
  // handlers
  exitGuard.promise = new Promise(resolve => {
    exitGuard.exit = resolve;
  });


  await worker.start();

  exitcode = await exitGuard.promise;

  cliArgs.verbose >= 1 && console.log(`418: exit guard called with ${exitcode}`);

  const exitTimeAllowed = 30;   // seconds to allow for worker to stop gracefully
  const forceExitTimeout = setTimeout(() => {
    console.error(`396: Worker failed to exit within ${exitTimeAllowed} seconds; terminating forcibly.`);
    process.exit(exitcode || EXIT_TIMED_OUT)
  }, exitTimeAllowed * 1000);

  await worker.stop(true)
  .catch(error => {
    if (error.message.includes('Already stopped'))
      return;
    console.error('255: Unexpected error stopping worker:',
      error.code
      ? `${error.code}: ${error.message}`
      : error.message);
    exitcode = exitcode || EXIT_ERROR_STOPPING;
  });

  clearTimeout(forceExitTimeout);

  return exitcode;
}

// Create the PID file for the worker
function memoizePid(dir)
{
  const path = require('path');
  const program = path.basename(require.main.filename, '.js');
  let location;
  let filename;

  if (dir.length && dir.length > 0)
  {
    location = path.dirname(dir);
    if (fs.existsSync(dir))
    {
      if (fs.statSync(dir).isDirectory())
        filename = program;
      else
      {
        console.warn('Previous PID file was not cleaned up');
        filename = path.basename(dir);
      }
    }
    else if (dir.endsWith(path.sep))
      filename = program;
    else
      filename = path.basename(dir);
  }
  else
  {
    location = DEFAULT_PID_LOC;
    filename = program;
  }

  const pidfile = path.join(
    location,
    filename + '.pid'
  )
  try
  {
    if (fs.existsSync(pidfile))
    {
      const oldPid = fs.readFileSync(pidfile, 'utf8')
      console.warn(`Warning: Previous invocation${oldPid.length ? ' pid#' + parseInt(String(oldPid)) : ''} did not remove ${pidfile}`);
    }
    else
      memoizePid.fd = fs.openSync(pidfile, 'wx');

    fs.writeSync(memoizePid.fd, Buffer.from(process.pid + '\n'), 0);
  }
  catch (error)
  {
    console.warn(`Warning: Could not create pidfile at ${pidfile} (${error.code || error.message})`);
    
    if (typeof memoizePid.fd === 'number')
    {
      fs.closeSync(memoizePid.fd);
      delete memoizePid.fd;
    }
    return;
  }

  

  function exitHandler()
  {
    try
    {
      fs.unlinkSync(pidfile);
      fs.closeSync(memoizePid.fd);
      delete memoizePid.fd;
    }
    catch (error)
    {
      console.warn(`Warning: Could not remove pidfile at ${pidfile} (${error.code})`);
    }
  }
  
  // Cleanup PID file
  process.on('dcpExit', exitHandler);
}

/** 
 * Unhandled rejection handler: __must not ever throw no matter what__.
 * If we hit an unhandled rejection, we are by definition no longer confident of our program state, meaning that
 * the worker must be restarted. This handler does its best to report the rejection and give the worker a few
 * seconds in which to attempt to return slices to the scheduler before it gives up completely.
 */
async function unhandledRejectionHandler (error) {
  let _worker = worker;
  
  if (!worker)
    return;
  else
    worker = false;

  try {
    let log = dcpConfig && dcpConfig.worker && dcpConfig.worker.unhandledRejectionLog;
    if (!log) log = process.env.DCP_WORKER_UNHANDLED_REJECTION_LOG;
    if (log) {
      fs.appendFileSync(process.env.DCP_WORKER_UNHANDLED_REJECTION_LOG,
                        `${Date.now()}: ${error.message}\n${error.stack}\n\n`);
    }
  } catch(e) {};

  try {
    let screen = require('../lib/worker-loggers/dashboard').screen;

    if (screen) {
      screen.log(error.message + '\n' + error.stack);
      screen.destroy();
      logError(error.message + '\n' + error.stack);
    } else {
      console.error('Unhandled rejection - preparing to exit:', error.message);
    }
  } catch(e) {};
  
  function bail(exitCode) {
    try {
      const util = require('util');
      process.stderr.write('\nWorker stop timeout; bailing due to earlier unhandled rejection:\n');
      process.stderr.write(util.inspect(error) + '\n');
    } catch(e) {
      console.error(error);
    }
    process.exit(exitCode || EXIT_UNHANDLED);
  }
  setTimeout(bail, 1000 * unhandledRejectionHandler.timeout);

  try {
    await _worker.stop(true);
  } catch(e) {
    console.log('Error during worker.stop:', e);
  }

  setImmediate(() => bail(EXIT_UNHANDLED));
};
unhandledRejectionHandler.timeout = 5;
