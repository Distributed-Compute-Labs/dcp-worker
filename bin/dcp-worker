#!/usr/bin/env node
/**
 *  @file       dcp-worker.js
 *              Standalone NodeJS DCP Worker
 *
 *  @author     Ryan Rossiter, ryan@kingsds.network
 *  @date       April 2020
 */
'use strict';

const process = require('process');
const os      = require('os');
const fs      = require('fs');
const crypto  = require('crypto');
const chalk   = require('chalk');

const configName = process.env.DCP_CONFIG || '../etc/dcp-worker-config';
const TOTAL_CPU_VCORES = os.cpus().length;
var worker, dcpConfig;

const EXIT_UNHANDLED = 5;

/* Setup the telnet REPL up early to ensure early-failure log messages are captured */
const replHelpers = {
  help: {
    report: 'Print a worker status & slice report',
    kill: 'Try to kill the worker',
    die:  'Kill the worker',
  },
  commands: {
    report: printReport,
    kill:   process.exit,
    die:    () => worker && worker.stop()
  },
};
require('../lib/remote-console').init(replHelpers);

/* Initialize dcp-client with local config defaults and run the main function. DCP_CONFIG_COOKIE becomes dcpConfig.cookie. */
process.env.DCP_CONFIG_COOKIE = (Math.random().toString(16)).slice(2) + '-' + process.pid + '-' + Date.now();
require('dcp-client').init({ configName }).then(main).catch(handleUnhandled);

function parseCliArgs()
{
  var defaultPidFileName;
  
  dcpConfig = require('dcp/dcp-config');
  defaultPidFileName = require('../lib/pidfile').getDefaultPidFileName(dcpConfig.worker.pidfile);
  
  const cliArgs = require('dcp/cli')
  .base('Standalone NodeJS DCP Worker')
    .options({
      paymentAddress: {
        describe: 'The address to deposit funds into, will use the default bank keystore if not provided.',
        type: 'string',
      },
      cores: {
        alias: 'c',
        describe: 'Number of cores to work with',
        type: 'number',
        default: TOTAL_CPU_VCORES - 1,
      },
      verbose: {
        alias: 'v',
        describe: 'Enable verbose output',
        type: 'count',
        default: false,
        group: 'Output options',
      },
      outputMode: {
        alias: ['o', 'output'],
        describe: 'Set the output mode',
        type: 'string',
        default: 'detect',
        choices: ['detect', 'console', 'dashboard', 'event-log', 'syslog', 'logfile'],
        group: 'Output options',
      },
      hostname: {
        alias: 'H',
        describe: 'Evaluator hostname',
        type: 'string',
        default: dcpConfig.evaluator.location.hostname,
      },
      port: {
        alias: 'p',
        describe: 'Evaluator port',
        type: 'number',
        default: Number(dcpConfig.evaluator.listen.port),
      },
      priorityOnly: {
        alias: 'P',
        describe: 'Set the priority mode [deprecated]',
        type: 'boolean',
        default: false
      },
      'job-id': {
        alias: 'j',
        describe: 'Restrict worker to a specific job (use N times for N jobs)',
        type: 'array',
      },

      join: {
        alias: 'g',
        describe: 'Join compute group; the format is "joinKey,joinSecret" or "joinKey,eh1-joinHash"',
        type: 'array'
      },
      joinKeystore: {
        hidden: true,
        /* future */
      },

      leavePublicGroup: {
        type: 'boolean',
        describe: 'Do not fetch slices from public compute group',
        default: false,
      },
      publicGroupFallback: {
        describe: 'If set, worker will prefer private groups but fall back on the public group if no preferred work is available',
        type: 'boolean',
        default: false,
      },

      identityKey: {
        describe: 'Identity key, in hex format',
        type: 'string',
        group: 'Identity options',
      },
      identityKeystore: {
        describe: 'Identity keystore, in json format',
        type: 'string',
        group: 'Identity options',
      },

      reportInterval: {
        describe: 'If set, output a status summary every [interval] seconds in console output mode',
        type: 'number',
        group: 'Output options',
      },
      eventDebug: {
        hide: true,
        describe: 'If set, dump all sandbox and worker events',
      },

      showConfig: {
        hide: false,
        describe: 'Show merged configuration node (eg worker)',
      },

      logfile: {
        describe: 'Path to log file (if --output=file)',
        type: 'string',
        group: 'Log File output options',
      },
      syslogAddress: {
        describe: 'Address of rsyslog server (if --output=syslog)',
        type: 'string',
        group: 'Syslog output options',
      },
      syslogTransport: {
        describe: 'Transport to connect to rsyslog daemon (if --output=syslog)',
        type: 'string',
        choices: ['udp','tcp'],
        group: 'Syslog output options',
      },
      syslogPort: {
        describe: 'UDP/TCP port of rsyslog server',
        type: 'number',
        group: 'Syslog output options',
      },

      allowedOrigins: {
        alias: 'a',
        describe: 'modify the \'any\' allow origins of dcpConfig',
        type: 'array'
      },

      watchdogInterval: {
        alias: 'W',
        describe: 'Number of milliseconds between watchdog cycles',
        type: 'number',
        hidden: true,
      },
      dumpConfig: {
        describe: 'If set, dump the configuration and exit',
        type: 'boolean',
        hidden: true,
      },
      pidFile: {
        alias: 'f',
        describe: `create a .pid file for the worker; value overrides default location (${defaultPidFileName})`,
        normalize: true
      },
    })
  .strict()
  .wrap(process.stdout.columns || 80)
  .argv;

  if (cliArgs.showConfig)
  {
    console.log(eval('dcpConfig.' + cliArgs.showConfig));
    process.exit();
  }

  if (cliArgs.dumpConfig)
  {
    console.debug(JSON.stringify(require('dcp/dcp-config'), null, 2));
    process.exit(0);
  }

  return cliArgs;
}

// Imperfect, but handles CG { joinKey, joinHash }.
function isHash(b) {
  return b && b.length === 68 && b.startsWith('eh1-');
}

/**
 * Add one or more configuration objects into a target via leaf-merging.
 */
function addConfig(target, ...objs)
{
  const { leafMerge } = require('dcp/utils');
  var tmp = target;

  for (let obj of objs)
    tmp = leafMerge(tmp, obj);

  Object.assign(target, tmp);
}

/**
 * Main program entry point. Assumes DCP client is already initialized and console logging is ready.
 */
async function main()
{
  const wallet = require('dcp/wallet');
  const DCPWorker = require('dcp/worker').Worker;
  const { startWorkerLogger } = require('../lib/startWorkerLogger');
  const cliArgs = parseCliArgs();
  const sawOptions = {
    hostname: cliArgs.hostname,
    port:     cliArgs.port
  };

  verifyDefaultConfigIntegrity();

  process.on('SIGINT', handleSigDeath);
  process.on('SIGTERM', handleSigDeath);
  process.on('SIGQUIT', handleSigDeath);
  process.on('unhandledRejection', handleUnhandled);
  process.on('uncaughtException', handleUnhandled);

  let paymentAddress = false
      || cliArgs.paymentAddress
      || dcpConfig.worker.paymentAddress
      || (await wallet.get()).address;
  if (typeof paymentAddress === 'string')
    paymentAddress = new wallet.Address(paymentAddress);
    
  if (cliArgs.pidFile)
    require('../lib/pidfile').write(cliArgs.pidFile);

  /* Figure out of the worker's identity and put that keystore in the wallet */
  let identityKeystore = false;
  if (cliArgs.identityKey)
    identityKeystore = await new wallet.IdKeystore(cliArgs.identityKey, '');
  else if (cliArgs.identityKeystore)
    identityKeystore = await new wallet.IdKeystore(JSON.parse(cliArgs.identityKeystore), '');
  else
    identityKeystore = await wallet.getId();
  await wallet.addId(identityKeystore);

  /* Build the worker options, which are largely given by dcpConfig.worker. We use a reference for 
   * dcpConfig.worker rather than copying it, so that runtime modifications to the worker configuration
   * in memory take effect immediately.
   *
   * forceOptions override any setting in dcpConfig; this can be used for settings calculated above
   * which were derived from dcpConfig in the first place. defaultOptions are overrideable by the usual
   * dcpConfig mechanisms, but since they are dynamic (or non-user-facing) they don't come from the
   * etc/dcp-worker-config.js file that ships with the work.
   */
  const dcpWorkerOptions = dcpConfig.worker;
  const forceOptions = {
    paymentAddress,
    leavePublicGroup: cliArgs.leavePublicGroup || dcpConfig.worker.leavePublicGroup || cliArgs.publicGroupFallback || false,
    maxWorkingSandboxes: cliArgs.cores,
  };
  const defaultOptions = {
    sandboxOptions: {
      SandboxConstructor: require('dcp-client/lib/standaloneWorker').workerFactory(sawOptions)
    },
  };

  addConfig(dcpWorkerOptions, defaultOptions, dcpConfig.worker, forceOptions);

  /* cliArgs.join is the list of compute groups to join */
  if (cliArgs.join && cliArgs.join.length)
  {
    const cliComputeGroups = cliArgs.join
      .map((el) => {
        /* Map cliArgs.join to give us [{ joinKey, joinSecret/joinHash }...] */
        const [a, b] = el.split(',');
        return isHash(b) ? { joinKey: a, joinHash: b } : { joinKey: a, joinSecret: b };
      })
      .filter((el) => el.joinKey); /* Filter out entries with no joinKey */

    addConfig(dcpWorkerOptions.computeGroups, dcpWorkerOptions.computeGroups, cliComputeGroups);
  }

  if (cliArgs.jobId)
  {
    dcpWorkerOptions.jobAddresses.push(...cliArgs.jobId);
    dcpWorkerOptions.priorityOnly = true;
  }

  if (cliArgs.allowedOrigins)
  {
    if (!dcpWorkerOptions.allowOrigins)
      dcpWorkerOptions.allowOrigins = {};
    if (!dcpWorkerOptions.allowOrigins.any)
      dcpWorkerOptions.allowOrigins.any = [];
    dcpWorkerOptions.allowOrigins.any.push(...cliArgs.allowedOrigins);
  }
  if (cliArgs.watchdogInterval)
    dcpWorkerOptions.watchdogInterval = cliArgs.watchdogInterval;

  worker = new DCPWorker(identityKeystore, dcpWorkerOptions);
  worker.on('error', console.error);
  worker.on('warning', console.warn);

  /* Let incorrect event-loop references keep us alive when linked with a debug library, but
   * exit quickly/accurately for production code even when the library isn't perfect.
   */
  if (require('dcp/build').config.build !== 'debug')
    worker.on('end', process.exit);
  else
    worker.on('end', () => setTimeout(process.exit, getCleanupTimeoutMs()).unref());

  if (cliArgs.eventDebug)
  {
    worker.debug = true;
    worker.supervisor.debug = true;
  }

  worker.on('stop', () => { console.log('Worker is stopping') });
  worker.on('end',  () => { logClosing('log', 'Worker has stopped') });
  startWorkerLogger(worker, cliArgs);

  require('../lib/remote-console').setMainEval(function mainEval() { return eval(arguments[0]) });

  let introBanner = '';
  introBanner += ` * Starting DCP Worker` + '\n';
  introBanner += ` . Configured for scheduler ${dcpConfig.scheduler.location}` + '\n';
  introBanner += ` . Bank is ${dcpConfig.bank.location}` + '\n';
  introBanner += ` . Earned funds will be deposited in account ${paymentAddress}` + '\n';
  introBanner += ` . Identity is ${identityKeystore.address}` + '\n';

  function qty(amount, singular, plural) /* XXX i18n */
  {
    if (Array.isArray(amount))
      amount = amount.length;
    if (!plural)
      plural = singular + 's';
    if (!amount)
      return plural;
    if (Number(amount) === 1)
      return singular;
    return plural;
  }

  if (dcpWorkerOptions.jobAddresses)
    introBanner += ` * Processing only ${qty(dcpWorkerOptions.jobAddresses, 'job')} ` + dcpWorkerOptions.jobAddresses.join(', ') + '\n';
  if (dcpWorkerOptions.computeGroups.length)
    introBanner += ` * Joining compute ${qty(dcpWorkerOptions.computeGroups, 'group')} ` + dcpWorkerOptions.computeGroups.map(el => el.joinKey).join(', ') + '\n';
  if (dcpWorkerOptions.publicGroupFallback)
    introBanner += ' * Falling back on public group when preferred groups have no work' + '\n';
  else if (dcpWorkerOptions.leavePublicGroup)
    introBanner += ' * Leaving the public compute group' + '\n';
  if (cliArgs.verbose)
    introBanner += ` + Verbosity level: ${cliArgs.verbose}` + '\n';
  if (cliArgs.eventDebug)
    introBanner += ' + Event debug on' + '\n';
  introBanner += ' . output mode: ' + cliArgs.outputMode + '\n';
  
  introBanner += ' . ready' + '\n';

  console.log(introBanner);
  require('../lib/check-scheduler-version').check();

  if (parseFloat(cliArgs.reportInterval))
  {
    if (cliArgs.outputMode !== 'dashboard')
      setInterval(printReport, parseFloat(cliArgs.reportInterval) * 1000).unref();
    else
      console.log('Ignoring --reportInterval in dashboard output mode');
  }

  /* Start the worker. Normal process exit happens by virtue of the worker<end> event */
  await worker.start();
}

/**
 * Log a closing message (or messages). Since the dashboard clears the screen on exit, we use the
 * memoized console property to log the message after we destroy the instance of screen.
 */
function logClosing(facility, ...message) 
{
  var screen = require('../lib/worker-loggers/dashboard').screen;

  if (!screen)
    console[facility](message);
  else
  {
    /* Turn off fullscreen TUI and resume "normal" console logging.
     * FUTURE: dashboard API should know how to unregister its hook so that we don't have to clobber
     *         it here.
     */
    screen.log(...message);
    screen.destroy();
    screen = false;
    console = new (require('console').Console)(process);
    require('../lib/remote-console').reintercept();
    console[facility](...message);
  }
}

/** 
 * Fatal error handler: __must not ever throw no matter what__.
 * If we hit a fatal error, we are by definition no longer confident of our program state, meaning that
 * the worker must be restarted. This handler does its best to report the rejection and give the worker a few
 * seconds in which to attempt to return slices to the scheduler before it gives up completely.
 */
async function handleUnhandled(error)
{
  var _worker = worker;
  worker = false;

  process.exitCode = process.exitCode || EXIT_UNHANDLED;
  
  try
  {
    logClosing(error);
  } catch(e) {};

  if (!_worker)
    console.error('trapped unhandled error:', error)
  else
  {
    console.error('trapped unhandled error -- stopping worker:', error);
    _worker.on('end', process.exit);
    _worker.stop();
  }

  setTimeout(() => {
    logClosing('error', 'handleFatalError timeout - exiting now');
    process.exit();
  }, getCleanupTimeoutMs()).unref();

  try {
    let log = dcpConfig && dcpConfig.worker && dcpConfig.worker.unhandledRejectionLog;
    if (!log) log = process.env.DCP_WORKER_UNHANDLED_REJECTION_LOG;
    if (log) {
      fs.appendFileSync(process.env.DCP_WORKER_UNHANDLED_REJECTION_LOG,
                        `${Date.now()}: ${error.message}\n${error.stack}\n\n`);
    }
  } catch(e) {};
}

/** print the slice report via console.log */
function printReport()
{
  console.log(sliceReport());
}

/**
 *  Convert a timespan in ms to a human-readable interval in minutes and seconds
 *
 *  @param  {number} el Milliseconds to convert
 *  @return {string}    Timespan formatted as `m:ss`
 */
function toInterval(el)
{
  const m = Math.floor((el / 1000) / 60).toString(10);
  const s = Math.floor((el / 1000) % 60).toString(10).padStart(2, '0');
  return `${m}:${s}`;
}

/** retrieve a slice report screen */
function sliceReport()
{
  const sup = worker.supervisor;
  let report = '';

  report += ('='.repeat(78)) + '\n';

  const sbStates = {
    WORKING: 0,
    ASSIGNED: 0,
    READY: 0,
    TERMINATED: 0,
  };
  const stateNames = {
    WORKING: 'Working',
    ASSIGNED: 'Assigned',
    READY: 'Ready',
    TERMINATED: 'Terminated',
  };
  sup.sandboxes.forEach(sb => {
    const { state } = sb;
    if (!sbStates[state])
      sbStates[state] = 0;
    sbStates[state]++;
  });

  report += (Date()) + '\n';
  report += ('Sandboxes:') + '\n';
  Object.keys(sbStates).forEach(state => {
    const stateName = stateNames[state] || state;
    report += (`  ${(stateName + ':').padEnd(12)} ${sbStates[state]}`) + '\n';
  })
  report += (`  * ALL:       ${sup.sandboxes.length}`) + '\n';

  report += ('Progress:') + '\n';
  sup.workingSandboxes.forEach(sb => {
    const jobName = sb.job && sb.job.public && sb.job.public.name || `idek (${sb.jobAddress})`;
    let el = Date.now() - sb.sliceStartTime;
    const t = el < 1000000
          ? toInterval(el)
          : 'new';

    el = sb.progressReports && sb.progressReports.last
      ? Date.now() - (sb.sliceStartTime + sb.progressReports.last.timestamp)
      : 0;
    const pct = (typeof sb.progress) === 'number'
          ? `${Number(sb.progress).toFixed(0).padStart(2)}%`
          : 'ind';
    const stale = (el < 2000) ? '' : `(stale: ${toInterval(el)})`;

    report += (` ${String(sb.id).padStart(4)}: ${sb.jobAddress} ${jobName.padEnd(34)} `+ `${t} ${pct} ${stale}`.padStart(13)) + '\n';
  });

  report += ('Slices:') + '\n';
  report += (`  working:     ${sup.allocatedSlices.length}`) + '\n';
  report += (`  queued:      ${sup.queuedSlices.length}`) + '\n';

  report += ('='.repeat(78)) + '\n';

  return report;
}

/**
 * Handle a signal which requests our the death of the Worker by 
 *  - stopping the worker
 *  - unregistering the handler (this allows a second signal to forcibly terminate the process
 *    if that is the default behaviour)
 *  - set a long timeout (dcpConfig.worker.cleanupTimeout seconds), after which the process
 *    exits forcibly with a non-zero exit code (unix standard for various signals)
 */
function handleSigDeath(signalName, signal)
{
  process.off(signalName, handleSigDeath);

  if (!worker)
    console.error(`trapped ${signalName}, signal ${signal}`);
  else
  {
    console.error(`trapped ${signalName}, signal ${signal} -- stopping worker`);
    worker.stop();
  }

  setTimeout(() => process.exit(signal - 128), getCleanupTimeoutMs()).unref();
}

/**
 * Returns the duration of the cleanup timeout in milliseconds. It is possible to specify zero.
 */
function getCleanupTimeoutMs()
{
  const defaultCT = 60;
  var cleanupTimeout = dcpConfig.worker.cleanupTimeout;

  if (typeof cleanupTimeout === 'undefined')
    cleanupTimeout = defaultCT;
  if (typeof cleanupTimeout !== 'number')
    cleanupTimeout = Number(cleanupTimeout)
  if (isNaN(cleanupTimeout))
  {
    cleanupTimeout = defaultCT;
    if (!getCleanupTimeoutMs.warned)
    {
      console.warn(`warning: dcpConfig.worker.cleanupTimeout is not a number (${dcpConfig.worker.cleanupTimeout})`);
      getCleanupTimeoutMs.warned = true;
    }
  }
  return cleanupTimeout * 1000;
}

/**
 * Ensure the default configuration hasn't been modified by the end-user-sysadmin. It is an 
 * attractive nuisance, as it looks just like the file they should modify, but if they make
 * security changes there that are overwritten in an subsequent update, it will be a problem.
 *
 * Every time a new package is generated, the default config file has its md5 checksum recorded
 * via the pack npm hook; all we do is make sure it hasn't changed.
 */
function verifyDefaultConfigIntegrity()
{
  const workerConfPath = require('dcp-client').__cn;
  const md5sumPath = workerConfPath + '.md5';

  if (!fs.existsSync(md5sumPath))
  {
    console.log(chalk.bold.red(` ! warning: ${md5sumPath} not found; cannot verify configuration integrity`));
    require('dcp/utils').sleep(2);
  }
  else
  {
    const originalMd5sum = fs.readFileSync(md5sumPath, 'ascii');
    const actualMd5sum = crypto.createHash('md5')
          .update(fs.readFileSync(workerConfPath, 'ascii'))
          .digest('hex');

    if (!originalMd5sum.startsWith(actualMd5sum))
    {
      console.warn(chalk.yellow(` ! Detected modified ${workerConfPath};`));
      console.warn(' . DCP Worker configuration changes should not be made by updating the default');
      console.warn('   config, as that file will be overwritten on the next npm update. Instead,');
      console.warn('   make changes via one of the following locations:');
      console.warn('    - ~/.dcp/dcp-worker/dcp-config.js');
      console.warn('    - /etc/dcp/dcp-worker/dcp-config.js');
      console.warn('    - /etc/override/dcp/dcp-worker/dcp-config.js');
      console.warn('    - the Windows Registry');

      if (require('dcp/build').config.build !== 'debug')
        process.exit(1);

      console.log(chalk.bold.red.inverse("If this wasn't a debug build, the worker would exit now."));
      require('dcp/utils').sleep(2);
    }
  }

  if (dcpConfig.cookie !== process.env.DCP_CONFIG_COOKIE || !dcpConfig.cookie)
  {
    console.error(' ! DCP Worker default configuration was not loaded; exiting.');
    process.exit(1);
  }
}
